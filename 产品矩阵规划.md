# 小程序产品矩阵开发计划

**创建时间：** 2025-10-31  
**状态：** 规划中  
**目标：** 构建一个以公众号为枢纽的小程序矩阵，实现流量互导和会员体系打通

---

## 📋 目录

1. [核心想法](#核心想法)
2. [技术可行性分析](#技术可行性分析)
3. [具体实施方案](#具体实施方案)
4. [代码示例](#代码示例)
5. [分阶段实施计划](#分阶段实施计划)
6. [风险与注意事项](#风险与注意事项)

---

## 💡 核心想法

### 产品矩阵布局

```
                    【微信公众号】
                    （流量中心枢纽）
                           |
        ┌──────────────────┼──────────────────┐
        |                  |                  |
   【喵喵美颜】        【PDF转JPG】        【答题小程序】
   图片增强工具         文档工具类          知识问答类
        |                  |                  |
        └──────────────────┴──────────────────┘
                           |
                    【小游戏系列】
                    休闲游戏 + 广告
```

### 核心机制

1. **公众号作为枢纽**
   - 发布任务、发放兑换码
   - 整点抢券（每天固定时间刷新额度池）
   - 串联所有小程序和小游戏

2. **统一会员体系**
   - 任何一个小程序的付费会员，所有工具都可以通用
   - 基于 UnionID 识别同一用户

3. **多元化获取额度**
   - 关注公众号：+50 次
   - 整点抢券：先到先得（如每天12:00刷新100个名额，每个+50次）
   - 小游戏闯关：通关弹出兑换码
   - 答题任务：答对一定数量获得兑换码
   - 观看视频广告：+5 次
   - 分享给好友：双方各 +10 次

4. **裂变分享机制（需谨慎）**
   - A用户付费会员 → 获得1个赠送名额（15天会员，仅限赠送，7天有效期）
   - B接收 → 获得15天免费会员 + 新的赠送名额（7天会员）
   - C接收 → 获得7天免费会员 + 新的赠送名额（3天会员）
   - D接收 → 获得3天会员 + 新的赠送名额（1天会员）
   - E接收 → 获得1天会员（链条结束）

5. **饥饿营销**
   - 整点抢券：限时限量，增加紧迫感
   - 社交证明："🔥 已有 23 人领取，手慢无！"
   - 活动提醒：订阅消息提醒用户"10分钟后开抢"

---

## 🔍 技术可行性分析

### 1. 公众号关注检测

#### ❌ 无法直接检测
- 小程序无法直接调用 API 查询用户是否关注公众号
- 必须通过公众号主动通知或用户操作来确认

#### ✅ 可行方案

**方案1：公众号菜单跳转（推荐）⭐**
```
流程：
1. 用户关注公众号
2. 点击公众号菜单"领取50次额度"
3. 跳转小程序时携带 openid/unionid
4. 小程序验证身份 → 发放50次

优点：
- 可靠性高
- 用户体验好
- 无需额外验证

实现：
- 公众号后台设置自定义菜单
- 菜单跳转链接携带参数：weixin://wxaurl?path=pages/index/index&from=gzh&openid=xxx
```

**方案2：验证码机制（最简单）⭐⭐**
```
流程：
1. 用户在小程序内点击"关注公众号领50次"
2. 显示公众号二维码
3. 用户关注后，在公众号回复关键词"领取额度"
4. 公众号自动回复验证码（6位数字）
5. 用户在小程序输入验证码
6. 验证通过 → 发放50次

优点：
- 简单易实现
- 无需复杂的参数传递
- 用户可以随时验证

实现：
- 服务端生成验证码（6位数字，5分钟有效）
- Redis 存储：code:123456 → {userId: xxx, expireAt: xxx}
- 小程序输入验证码 → 服务端验证 → 发放额度
```

**方案3：带参数二维码**
```
流程：
1. 小程序生成专属二维码（带用户标识）
2. 用户扫码关注公众号
3. 公众号后台接收 subscribe 事件（携带用户标识）
4. 服务端标记该用户已关注
5. 小程序轮询查询状态 → 发放额度

优点：
- 可以精确追踪每个用户

缺点：
- 需要生成大量二维码
- 小程序需要轮询
```

**推荐：方案2（验证码机制）**
- 最简单、最可靠
- 用户体验好
- 成本低

---

### 2. 取关检测 & 反复关注-取关

#### ✅ 完全可以检测

**微信事件推送：**
```javascript
// 公众号后台接收微信事件
{
  event: 'subscribe',   // 关注事件
  openid: 'xxx',
  timestamp: 1698825600
}

{
  event: 'unsubscribe', // 取关事件
  openid: 'xxx',
  timestamp: 1698826000
}
```

**反作弊策略：**

1. **记录用户关注历史**
   ```typescript
   interface UserFollowHistory {
     openid: string;
     unionid: string;
     actions: {
       type: 'subscribe' | 'unsubscribe';
       timestamp: number;
     }[];
     rewardCount: number; // 已领取奖励次数
   }
   ```

2. **检测异常行为**
   ```typescript
   function isAbnormalBehavior(history: UserFollowHistory): boolean {
     const last7Days = history.actions.filter(
       a => a.timestamp > Date.now() - 7 * 24 * 3600 * 1000
     );
     
     const subscribeCount = last7Days.filter(a => a.type === 'subscribe').length;
     
     // 7天内关注-取关超过3次
     if (subscribeCount > 3) {
       return true;
     }
     
     // 关注后10分钟内取关
     for (let i = 0; i < history.actions.length - 1; i++) {
       if (history.actions[i].type === 'subscribe' && 
           history.actions[i+1].type === 'unsubscribe' &&
           history.actions[i+1].timestamp - history.actions[i].timestamp < 600000) {
         return true;
       }
     }
     
     return false;
   }
   ```

3. **限制奖励**
   ```typescript
   async function handleSubscribe(openid: string) {
     const history = await getFollowHistory(openid);
     
     // 检测异常
     if (isAbnormalBehavior(history)) {
       console.log('检测到异常行为，不发放奖励');
       return;
     }
     
     // 限制奖励次数（如每个用户只能领取1次）
     if (history.rewardCount >= 1) {
       console.log('该用户已领取过奖励');
       return;
     }
     
     // 发放奖励
     await grantQuota(openid, 50);
     history.rewardCount++;
     await saveFollowHistory(history);
   }
   ```

**取关后的处理：**
- ✅ 可以收回已发放的额度（如果检测到取关）
- ⚠️ 但注意：用户取关后，公众号无法主动给用户发消息（除非48小时内有互动）

---

### 3. 整点抢券 + 消息提醒

#### ✅ 可以实现

**小程序订阅消息（推荐）：**
```typescript
// 前端：用户授权订阅
wx.requestSubscribeMessage({
  tmplIds: ['整点抢券提醒模板ID'],
  success: (res) => {
    if (res['整点抢券提醒模板ID'] === 'accept') {
      // 用户同意接收提醒
      // 服务端记录，定时推送
    }
  }
})

// 后端：定时推送（如每天11:50）
await sendSubscribeMessage({
  touser: 'openid',
  template_id: '整点抢券提醒模板ID',
  page: 'pages/index/index',
  data: {
    thing1: { value: '整点抢券活动' },
    time2: { value: '2025-10-31 12:00' },
    thing3: { value: '100个名额，先到先得' }
  }
})
```

**公众号服务通知（受限）：**
- ⚠️ 需要用户48小时内与公众号有互动
- ⚠️ 或使用"一次性订阅消息"（需用户主动订阅）

**推荐方案：**
1. 小程序订阅消息（提前10分钟提醒）
2. 公众号每天推送一篇文章（如每天11:00推送"今日整点福利"）

---

### 4. 社交证明（"已有23人领取"）

#### ✅ 完全可行

**实时统计：**
```typescript
// Redis 实时计数
const key = `coupons:claimed:${new Date().toDateString()}:12:00`;

// 每次领取时增加
await redis.incr(key);

// 查询
const claimedCount = await redis.get(key) || 0;

// 前端显示
"🔥 已有 {{claimedCount}} 人领取，手慢无！"
```

**进度条显示：**
```typescript
// 总名额
const total = 100;

// 已领取
const claimed = await redis.get(key) || 0;

// 剩余
const remaining = total - claimed;

// 前端显示
"⏰ 仅剩 {{remaining}} 个名额（{{Math.floor(claimed/total*100)}}% 已被抢）"
```

**领取动态：**
```typescript
// 记录最近领取的用户（脱敏）
await redis.lpush(`coupons:recent:${date}`, {
  nickname: '***123',
  timestamp: Date.now()
});

// 前端显示（滚动播报）
"🎉 恭喜用户 ***123 领取成功"
"🎉 恭喜用户 ***456 领取成功"
```

---

### 5. 裂变分享机制（会员递减赠送）

#### ✅ 技术上完全可行

**赠送规则：**
```typescript
const GIFT_RULES = {
  level1: { days: 15, nextLevel: 'level2', expireDays: 7 }, // A赠送15天
  level2: { days: 7,  nextLevel: 'level3', expireDays: 7 }, // B赠送7天
  level3: { days: 3,  nextLevel: 'level4', expireDays: 7 }, // C赠送3天
  level4: { days: 1,  nextLevel: null,     expireDays: 7 }, // D赠送1天，链条结束
};
```

**数据结构：**
```typescript
interface GiftQuota {
  userId: string;
  level: 'level1' | 'level2' | 'level3' | 'level4';
  days: number;          // 可赠送的天数
  expireAt: number;      // 过期时间（7天后）
  used: boolean;         // 是否已使用
  usedAt?: number;       // 使用时间
  giftedTo?: string;     // 赠送给谁
}

interface Membership {
  userId: string;
  type: 'paid' | 'gift';      // 付费会员 or 赠送会员
  expireAt: number;           // 会员到期时间
  giftFrom?: string;          // 如果是赠送，来自谁
  giftLevel?: string;         // 赠送等级
}
```

**核心逻辑：**
```typescript
// 付费后生成赠送名额
async function onUserPurchase(userId: string) {
  // 1. 开通会员
  await grantMembership(userId, 'paid', 30); // 30天付费会员
  
  // 2. 生成赠送名额
  await createGiftQuota({
    userId,
    level: 'level1',
    days: 15,
    expireAt: Date.now() + 7 * 24 * 3600 * 1000, // 7天后过期
    used: false
  });
  
  // 3. 通知用户
  await sendNotification(userId, '您获得了1个15天会员赠送名额，快去分享给好友吧！');
}

// 赠送会员
async function sendGift(fromUserId: string, toUserId: string) {
  // 1. 检查发送者是否有赠送资格
  const gift = await getGiftQuota(fromUserId);
  
  if (!gift) {
    throw new Error('您暂无赠送名额');
  }
  
  if (gift.used) {
    throw new Error('该赠送名额已使用');
  }
  
  if (gift.expireAt < Date.now()) {
    throw new Error('赠送名额已过期');
  }
  
  // 2. 检查接收者是否已经是会员
  const membership = await getMembership(toUserId);
  if (membership && membership.expireAt > Date.now()) {
    throw new Error('对方已经是会员了');
  }
  
  // 3. 发放会员给接收者
  await grantMembership(toUserId, 'gift', gift.days, fromUserId, gift.level);
  
  // 4. 给接收者生成新的赠送名额（递减）
  const nextLevel = GIFT_RULES[gift.level].nextLevel;
  if (nextLevel) {
    await createGiftQuota({
      userId: toUserId,
      level: nextLevel,
      days: GIFT_RULES[nextLevel].days,
      expireAt: Date.now() + 7 * 24 * 3600 * 1000,
      used: false
    });
  }
  
  // 5. 标记发送者的名额已使用
  await markGiftUsed(gift.id, toUserId);
  
  // 6. 通知双方
  await sendNotification(fromUserId, `您已成功赠送${gift.days}天会员给好友！`);
  await sendNotification(toUserId, `恭喜获得${gift.days}天免费会员！${nextLevel ? '您也获得了新的赠送名额！' : ''}`);
}
```

#### ⚠️ 合规风险

**微信严格禁止"诱导分享"：**
- ❌ "必须分享给5个好友才能解锁" → 违规
- ❌ "分享到朋友圈才能继续使用" → 违规
- ❌ "分享后显示答案" → 违规

**建议改为：**
- ✅ "可以赠送，但不强制"
- ✅ "赠送后自己也有奖励"（而不是"只能别人用"）
- ✅ 用户可以选择"分享"或"看广告"等多种方式获取

**修改后的安全方案：**
```typescript
// 付费后的奖励
async function onUserPurchase(userId: string) {
  // 1. 开通会员
  await grantMembership(userId, 'paid', 30);
  
  // 2. 自己也获得额外10天会员
  await extendMembership(userId, 10);
  
  // 3. 生成赠送名额（可选）
  await createGiftQuota({
    userId,
    level: 'level1',
    days: 15,
    expireAt: Date.now() + 7 * 24 * 3600 * 1000,
    used: false
  });
  
  // 4. 通知用户（强调"可以"而不是"必须"）
  await sendNotification(userId, 
    '感谢购买会员！\n' +
    '🎁 您已获得30天会员 + 10天奖励\n' +
    '💝 还可以赠送15天会员给好友（可选）'
  );
}
```

---

## 🛠️ 具体实施方案

### 方案1：公众号关注验证（验证码机制）

#### 数据库设计

```sql
-- 验证码表
CREATE TABLE verification_codes (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  code VARCHAR(6) NOT NULL,           -- 验证码（6位数字）
  user_id VARCHAR(64) NOT NULL,        -- 小程序用户ID（deviceId）
  openid VARCHAR(64),                  -- 公众号 openid（验证后填充）
  unionid VARCHAR(64),                 -- unionid（用于跨应用识别）
  type VARCHAR(20) NOT NULL,           -- 类型：follow_reward（关注奖励）
  status VARCHAR(20) NOT NULL,         -- 状态：pending/used/expired
  reward_value INT NOT NULL,           -- 奖励值（如50次）
  created_at BIGINT NOT NULL,          -- 创建时间
  expire_at BIGINT NOT NULL,           -- 过期时间（5分钟）
  used_at BIGINT,                      -- 使用时间
  INDEX idx_code (code),
  INDEX idx_user_id (user_id),
  INDEX idx_openid (openid)
);

-- 关注历史表
CREATE TABLE follow_history (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  openid VARCHAR(64) NOT NULL,
  unionid VARCHAR(64),
  event_type VARCHAR(20) NOT NULL,     -- subscribe/unsubscribe
  timestamp BIGINT NOT NULL,
  reward_granted BOOLEAN DEFAULT FALSE, -- 是否已发放奖励
  INDEX idx_openid (openid),
  INDEX idx_unionid (unionid),
  INDEX idx_timestamp (timestamp)
);
```

#### 前端流程（小程序）

```typescript
// pages/follow-reward/follow-reward.ts

Page({
  data: {
    step: 1,              // 步骤：1-生成验证码, 2-等待验证, 3-完成
    code: '',             // 验证码
    qrcodeUrl: '',        // 公众号二维码
    inputCode: '',        // 用户输入的验证码
    countdown: 300,       // 倒计时（5分钟）
    checking: false       // 是否正在验证
  },
  
  onLoad() {
    this.generateCode();
    this.startCountdown();
  },
  
  // 生成验证码
  async generateCode() {
    wx.showLoading({ title: '生成中...' });
    
    try {
      const res = await wx.request({
        url: 'https://your-api.com/api/verification/generate',
        method: 'POST',
        data: {
          userId: this.getDeviceId(),
          type: 'follow_reward'
        }
      });
      
      this.setData({
        code: res.data.code,
        qrcodeUrl: res.data.qrcodeUrl, // 公众号二维码
        step: 2
      });
      
      wx.hideLoading();
    } catch (error) {
      wx.hideLoading();
      wx.showToast({ title: '生成失败', icon: 'none' });
    }
  },
  
  // 倒计时
  startCountdown() {
    const timer = setInterval(() => {
      const countdown = this.data.countdown - 1;
      this.setData({ countdown });
      
      if (countdown <= 0) {
        clearInterval(timer);
        this.setData({ step: 1 });
        wx.showToast({ title: '验证码已过期', icon: 'none' });
      }
    }, 1000);
  },
  
  // 用户输入验证码
  onInputChange(e: any) {
    this.setData({ inputCode: e.detail.value });
  },
  
  // 验证验证码
  async verifyCode() {
    if (!this.data.inputCode || this.data.inputCode.length !== 6) {
      wx.showToast({ title: '请输入6位验证码', icon: 'none' });
      return;
    }
    
    this.setData({ checking: true });
    
    try {
      const res = await wx.request({
        url: 'https://your-api.com/api/verification/verify',
        method: 'POST',
        data: {
          code: this.data.inputCode,
          userId: this.getDeviceId()
        }
      });
      
      if (res.data.success) {
        this.setData({ step: 3 });
        wx.showToast({ title: '验证成功，已发放50次额度！', icon: 'success' });
        
        // 3秒后返回首页
        setTimeout(() => {
          wx.navigateBack();
        }, 3000);
      } else {
        wx.showToast({ title: res.data.message || '验证失败', icon: 'none' });
      }
    } catch (error) {
      wx.showToast({ title: '验证失败', icon: 'none' });
    } finally {
      this.setData({ checking: false });
    }
  },
  
  // 获取设备ID
  getDeviceId(): string {
    let deviceId = wx.getStorageSync('device_uuid');
    if (!deviceId) {
      deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      wx.setStorageSync('device_uuid', deviceId);
    }
    return deviceId;
  }
});
```

#### 后端流程（服务端）

```typescript
// 生成验证码
app.post('/api/verification/generate', async (req, res) => {
  const { userId, type } = req.body;
  
  // 1. 生成6位数字验证码
  const code = Math.floor(100000 + Math.random() * 900000).toString();
  
  // 2. 保存到数据库
  await db.verification_codes.insert({
    code,
    user_id: userId,
    type,
    status: 'pending',
    reward_value: 50,
    created_at: Date.now(),
    expire_at: Date.now() + 5 * 60 * 1000 // 5分钟后过期
  });
  
  // 3. 返回验证码和公众号二维码
  res.json({
    code,
    qrcodeUrl: 'https://your-cdn.com/qrcode.jpg' // 公众号二维码
  });
});

// 验证验证码
app.post('/api/verification/verify', async (req, res) => {
  const { code, userId } = req.body;
  
  // 1. 查询验证码
  const record = await db.verification_codes.findOne({
    code,
    user_id: userId,
    status: 'pending'
  });
  
  if (!record) {
    return res.json({ success: false, message: '验证码无效' });
  }
  
  if (record.expire_at < Date.now()) {
    return res.json({ success: false, message: '验证码已过期' });
  }
  
  if (!record.openid) {
    return res.json({ success: false, message: '请先在公众号回复验证码' });
  }
  
  // 2. 检查是否已领取过奖励
  const history = await db.follow_history.findOne({
    openid: record.openid,
    event_type: 'subscribe',
    reward_granted: true
  });
  
  if (history) {
    return res.json({ success: false, message: '您已经领取过关注奖励了' });
  }
  
  // 3. 发放奖励
  await grantQuota(userId, record.reward_value);
  
  // 4. 标记验证码已使用
  await db.verification_codes.update(
    { id: record.id },
    { status: 'used', used_at: Date.now() }
  );
  
  // 5. 标记关注历史已发放奖励
  await db.follow_history.update(
    { openid: record.openid, event_type: 'subscribe' },
    { reward_granted: true }
  );
  
  res.json({ success: true });
});

// 公众号后台接收用户消息
app.post('/api/wechat/message', async (req, res) => {
  const { FromUserName: openid, Content: content } = req.body;
  
  // 用户回复了6位数字
  if (/^\d{6}$/.test(content)) {
    // 查询验证码记录
    const record = await db.verification_codes.findOne({
      code: content,
      status: 'pending',
      openid: null // 尚未绑定 openid
    });
    
    if (record && record.expire_at > Date.now()) {
      // 绑定 openid
      await db.verification_codes.update(
        { id: record.id },
        { openid }
      );
      
      // 回复用户
      return res.send(`
        <xml>
          <ToUserName><![CDATA[${openid}]]></ToUserName>
          <FromUserName><![CDATA[your-gzh-id]]></FromUserName>
          <CreateTime>${Math.floor(Date.now() / 1000)}</CreateTime>
          <MsgType><![CDATA[text]]></MsgType>
          <Content><![CDATA[验证成功！请返回小程序继续操作。]]></Content>
        </xml>
      `);
    }
  }
  
  // 关键词回复
  if (content === '领取额度' || content === '关注奖励') {
    return res.send(`
      <xml>
        <ToUserName><![CDATA[${openid}]]></ToUserName>
        <FromUserName><![CDATA[your-gzh-id]]></FromUserName>
        <CreateTime>${Math.floor(Date.now() / 1000)}</CreateTime>
        <MsgType><![CDATA[text]]></MsgType>
        <Content><![CDATA[
📱 领取步骤：
1. 打开"喵喵美颜"小程序
2. 点击"关注领50次"按钮
3. 获取验证码
4. 在公众号回复验证码
5. 回到小程序完成验证

快去试试吧！
        ]]></Content>
      </xml>
    `);
  }
  
  res.send('success');
});

// 公众号后台接收关注/取关事件
app.post('/api/wechat/event', async (req, res) => {
  const { Event: event, FromUserName: openid } = req.body;
  
  // 记录关注历史
  await db.follow_history.insert({
    openid,
    event_type: event, // subscribe / unsubscribe
    timestamp: Date.now(),
    reward_granted: false
  });
  
  // 关注事件：回复引导
  if (event === 'subscribe') {
    return res.send(`
      <xml>
        <ToUserName><![CDATA[${openid}]]></ToUserName>
        <FromUserName><![CDATA[your-gzh-id]]></FromUserName>
        <CreateTime>${Math.floor(Date.now() / 1000)}</CreateTime>
        <MsgType><![CDATA[text]]></MsgType>
        <Content><![CDATA[
🎉 欢迎关注超清魔法公众号！

🎁 新用户福利：
关注即可领取 50 次免费额度！

📝 领取步骤：
1. 回复"领取额度"获取详细说明
2. 或直接在小程序内点击"关注领50次"

期待与你一起变美！✨
        ]]></Content>
      </xml>
    `);
  }
  
  // 取关事件：检测异常行为
  if (event === 'unsubscribe') {
    const history = await db.follow_history.find({
      openid,
      timestamp: { $gt: Date.now() - 7 * 24 * 3600 * 1000 }
    });
    
    const subscribeCount = history.filter(h => h.event_type === 'subscribe').length;
    
    if (subscribeCount > 3) {
      console.log(`检测到异常行为：${openid} 在7天内关注-取关超过3次`);
      // 可以标记该用户，限制后续奖励
    }
  }
  
  res.send('success');
});
```

---

### 方案2：整点抢券系统

#### 数据库设计

```sql
-- 抢券活动表
CREATE TABLE coupon_events (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  date DATE NOT NULL,                  -- 日期：2025-10-31
  time TIME NOT NULL,                  -- 时间：12:00:00
  total_quota INT NOT NULL,            -- 总名额：100
  reward_value INT NOT NULL,           -- 奖励值：50次
  claimed_count INT DEFAULT 0,         -- 已领取数量
  status VARCHAR(20) NOT NULL,         -- 状态：pending/active/finished
  start_at BIGINT NOT NULL,            -- 开始时间
  end_at BIGINT NOT NULL,              -- 结束时间
  created_at BIGINT NOT NULL,
  UNIQUE KEY uk_date_time (date, time)
);

-- 领取记录表
CREATE TABLE coupon_claims (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  event_id BIGINT NOT NULL,
  user_id VARCHAR(64) NOT NULL,
  openid VARCHAR(64),
  unionid VARCHAR(64),
  reward_value INT NOT NULL,
  claimed_at BIGINT NOT NULL,
  INDEX idx_event_id (event_id),
  INDEX idx_user_id (user_id),
  UNIQUE KEY uk_event_user (event_id, user_id)
);
```

#### 定时任务（每天创建活动）

```typescript
// 每天凌晨00:10创建今天的抢券活动
cron.schedule('10 0 * * *', async () => {
  const today = new Date().toISOString().split('T')[0];
  
  // 创建12:00的活动
  await db.coupon_events.insert({
    date: today,
    time: '12:00:00',
    total_quota: 100,
    reward_value: 50,
    claimed_count: 0,
    status: 'pending',
    start_at: new Date(`${today} 12:00:00`).getTime(),
    end_at: new Date(`${today} 12:30:00`).getTime(), // 30分钟内有效
    created_at: Date.now()
  });
  
  // 创建18:00的活动
  await db.coupon_events.insert({
    date: today,
    time: '18:00:00',
    total_quota: 100,
    reward_value: 50,
    claimed_count: 0,
    status: 'pending',
    start_at: new Date(`${today} 18:00:00`).getTime(),
    end_at: new Date(`${today} 18:30:00`).getTime(),
    created_at: Date.now()
  });
  
  console.log(`✅ 已创建 ${today} 的抢券活动`);
});

// 每分钟检查活动状态
cron.schedule('* * * * *', async () => {
  const now = Date.now();
  
  // 激活到时间的活动
  await db.coupon_events.update(
    { status: 'pending', start_at: { $lte: now } },
    { status: 'active' }
  );
  
  // 结束过期的活动
  await db.coupon_events.update(
    { status: 'active', end_at: { $lte: now } },
    { status: 'finished' }
  );
});
```

#### 后端API

```typescript
// 获取当前活动信息
app.get('/api/coupon/current', async (req, res) => {
  const now = Date.now();
  
  // 查询当前进行中的活动
  const event = await db.coupon_events.findOne({
    status: 'active',
    start_at: { $lte: now },
    end_at: { $gte: now }
  });
  
  if (!event) {
    // 查询下一场活动
    const nextEvent = await db.coupon_events.findOne({
      status: 'pending',
      start_at: { $gt: now }
    }, {
      sort: { start_at: 1 }
    });
    
    return res.json({
      status: 'waiting',
      nextEvent: nextEvent ? {
        startAt: nextEvent.start_at,
        totalQuota: nextEvent.total_quota,
        rewardValue: nextEvent.reward_value
      } : null
    });
  }
  
  // 从Redis获取实时数据
  const claimedCount = await redis.get(`coupon:claimed:${event.id}`) || 0;
  const remaining = event.total_quota - claimedCount;
  
  res.json({
    status: 'active',
    event: {
      id: event.id,
      totalQuota: event.total_quota,
      claimedCount: parseInt(claimedCount),
      remaining: remaining > 0 ? remaining : 0,
      rewardValue: event.reward_value,
      endAt: event.end_at
    }
  });
});

// 抢券
app.post('/api/coupon/claim', async (req, res) => {
  const { userId } = req.body;
  const now = Date.now();
  
  // 1. 查询当前活动
  const event = await db.coupon_events.findOne({
    status: 'active',
    start_at: { $lte: now },
    end_at: { $gte: now }
  });
  
  if (!event) {
    return res.json({ success: false, message: '当前没有进行中的活动' });
  }
  
  // 2. 检查用户是否已领取
  const claimed = await db.coupon_claims.findOne({
    event_id: event.id,
    user_id: userId
  });
  
  if (claimed) {
    return res.json({ success: false, message: '您已经领取过了' });
  }
  
  // 3. Redis原子操作（防止超发）
  const key = `coupon:claimed:${event.id}`;
  const claimedCount = await redis.incr(key);
  
  if (claimedCount > event.total_quota) {
    // 超过名额，回退
    await redis.decr(key);
    return res.json({ success: false, message: '名额已被抢完' });
  }
  
  // 4. 发放奖励
  try {
    await grantQuota(userId, event.reward_value);
    
    // 5. 记录领取
    await db.coupon_claims.insert({
      event_id: event.id,
      user_id: userId,
      reward_value: event.reward_value,
      claimed_at: Date.now()
    });
    
    // 6. 更新数据库计数（异步，不影响响应速度）
    db.coupon_events.update(
      { id: event.id },
      { $inc: { claimed_count: 1 } }
    );
    
    res.json({ 
      success: true, 
      message: `恭喜！已获得 ${event.reward_value} 次额度`,
      rewardValue: event.reward_value
    });
  } catch (error) {
    // 出错回退
    await redis.decr(key);
    res.json({ success: false, message: '领取失败，请重试' });
  }
});

// 获取最近领取动态（滚动播报）
app.get('/api/coupon/recent-claims', async (req, res) => {
  const { eventId } = req.query;
  
  const claims = await db.coupon_claims.find({
    event_id: eventId
  }, {
    sort: { claimed_at: -1 },
    limit: 10
  });
  
  // 脱敏处理
  const recentClaims = claims.map(c => ({
    nickname: '***' + c.user_id.substr(-3),
    timestamp: c.claimed_at
  }));
  
  res.json({ claims: recentClaims });
});
```

#### 前端UI（小程序）

```typescript
// pages/coupon/coupon.ts

Page({
  data: {
    status: 'loading',      // loading/waiting/active/finished
    event: null,
    countdown: 0,           // 倒计时（秒）
    recentClaims: [],       // 最近领取动态
    claiming: false
  },
  
  onLoad() {
    this.fetchCurrentEvent();
    this.startPolling();
  },
  
  // 获取当前活动
  async fetchCurrentEvent() {
    try {
      const res = await wx.request({
        url: 'https://your-api.com/api/coupon/current'
      });
      
      if (res.data.status === 'waiting') {
        // 等待下一场
        this.setData({
          status: 'waiting',
          countdown: Math.floor((res.data.nextEvent.startAt - Date.now()) / 1000)
        });
        this.startCountdown();
      } else if (res.data.status === 'active') {
        // 活动进行中
        this.setData({
          status: 'active',
          event: res.data.event,
          countdown: Math.floor((res.data.event.endAt - Date.now()) / 1000)
        });
        this.startCountdown();
        this.fetchRecentClaims(res.data.event.id);
      }
    } catch (error) {
      console.error('获取活动信息失败:', error);
    }
  },
  
  // 倒计时
  startCountdown() {
    const timer = setInterval(() => {
      const countdown = this.data.countdown - 1;
      this.setData({ countdown });
      
      if (countdown <= 0) {
        clearInterval(timer);
        // 刷新活动状态
        this.fetchCurrentEvent();
      }
    }, 1000);
  },
  
  // 轮询（每5秒刷新一次）
  startPolling() {
    setInterval(() => {
      if (this.data.status === 'active') {
        this.fetchCurrentEvent();
      }
    }, 5000);
  },
  
  // 获取最近领取动态
  async fetchRecentClaims(eventId: number) {
    try {
      const res = await wx.request({
        url: 'https://your-api.com/api/coupon/recent-claims',
        data: { eventId }
      });
      
      this.setData({ recentClaims: res.data.claims });
    } catch (error) {
      console.error('获取动态失败:', error);
    }
  },
  
  // 抢券
  async handleClaim() {
    if (this.data.claiming) return;
    
    this.setData({ claiming: true });
    
    try {
      const res = await wx.request({
        url: 'https://your-api.com/api/coupon/claim',
        method: 'POST',
        data: {
          userId: this.getDeviceId()
        }
      });
      
      if (res.data.success) {
        wx.showModal({
          title: '🎉 领取成功！',
          content: res.data.message,
          showCancel: false,
          success: () => {
            // 刷新页面
            this.fetchCurrentEvent();
          }
        });
      } else {
        wx.showToast({
          title: res.data.message,
          icon: 'none',
          duration: 2000
        });
      }
    } catch (error) {
      wx.showToast({
        title: '领取失败',
        icon: 'none'
      });
    } finally {
      this.setData({ claiming: false });
    }
  },
  
  getDeviceId(): string {
    let deviceId = wx.getStorageSync('device_uuid');
    if (!deviceId) {
      deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      wx.setStorageSync('device_uuid', deviceId);
    }
    return deviceId;
  }
});
```

```xml
<!-- pages/coupon/coupon.wxml -->

<view class="container">
  <!-- 等待下一场 -->
  <view wx:if="{{status === 'waiting'}}" class="waiting-section">
    <view class="title">⏰ 下一场整点抢券</view>
    <view class="countdown">{{countdown}}秒后开始</view>
    <view class="hint">请耐心等待...</view>
  </view>
  
  <!-- 活动进行中 -->
  <view wx:if="{{status === 'active'}}" class="active-section">
    <view class="title">🔥 整点抢券进行中</view>
    
    <!-- 进度条 -->
    <view class="progress-section">
      <view class="progress-bar">
        <view class="progress-fill" style="width: {{event.claimedCount / event.totalQuota * 100}}%;"></view>
      </view>
      <view class="progress-text">
        <text>已抢 {{event.claimedCount}}</text>
        <text>剩余 {{event.remaining}}</text>
      </view>
    </view>
    
    <!-- 奖励信息 -->
    <view class="reward-info">
      <text class="reward-value">+{{event.rewardValue}}</text>
      <text class="reward-label">次额度</text>
    </view>
    
    <!-- 抢券按钮 -->
    <button 
      bindtap="handleClaim" 
      disabled="{{claiming || event.remaining <= 0}}"
      class="claim-btn"
    >
      {{claiming ? '领取中...' : (event.remaining > 0 ? '立即抢券' : '已抢完')}}
    </button>
    
    <!-- 倒计时 -->
    <view class="countdown-hint">
      活动剩余时间：{{Math.floor(countdown / 60)}}分{{countdown % 60}}秒
    </view>
    
    <!-- 最近领取动态 -->
    <view class="recent-claims">
      <view class="recent-title">🎉 最近领取</view>
      <view wx:for="{{recentClaims}}" wx:key="timestamp" class="claim-item">
        <text>用户 {{item.nickname}} 刚刚领取成功</text>
      </view>
    </view>
  </view>
</view>
```

#### 订阅消息提醒

```typescript
// 定时任务：活动开始前10分钟推送提醒
cron.schedule('*/1 * * * *', async () => {
  const now = Date.now();
  const tenMinutesLater = now + 10 * 60 * 1000;
  
  // 查询即将开始的活动
  const events = await db.coupon_events.find({
    status: 'pending',
    start_at: { $gt: now, $lte: tenMinutesLater },
    reminded: { $ne: true }
  });
  
  for (const event of events) {
    // 查询订阅了提醒的用户
    const subscribers = await db.subscribers.find({
      type: 'coupon_reminder',
      enabled: true
    });
    
    // 批量推送
    for (const sub of subscribers) {
      await sendSubscribeMessage({
        touser: sub.openid,
        template_id: 'coupon_reminder_template_id',
        page: 'pages/coupon/coupon',
        data: {
          thing1: { value: '整点抢券活动' },
          time2: { value: new Date(event.start_at).toLocaleString() },
          thing3: { value: `${event.total_quota}个名额，每人+${event.reward_value}次` }
        }
      });
    }
    
    // 标记已提醒
    await db.coupon_events.update(
      { id: event.id },
      { reminded: true }
    );
    
    console.log(`✅ 已推送 ${subscribers.length} 条活动提醒`);
  }
});
```

---

### 方案3：兑换码系统

#### 数据库设计

```sql
-- 兑换码表
CREATE TABLE redemption_codes (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  code VARCHAR(20) NOT NULL UNIQUE,    -- 兑换码：MM-3K5J-2A9X
  source VARCHAR(50) NOT NULL,         -- 来源：game_level_10, quiz_task_1
  type VARCHAR(20) NOT NULL,           -- 类型：quota/membership
  value INT NOT NULL,                  -- 价值：20次 或 7天
  status VARCHAR(20) NOT NULL,         -- 状态：active/used/expired
  generated_at BIGINT NOT NULL,        -- 生成时间
  expire_at BIGINT NOT NULL,           -- 过期时间
  used_by VARCHAR(64),                 -- 使用者
  used_at BIGINT,                      -- 使用时间
  INDEX idx_code (code),
  INDEX idx_status (status)
);
```

#### 生成兑换码

```typescript
// 生成兑换码
function generateRedemptionCode(): string {
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substr(2, 4).toUpperCase();
  return `MM-${timestamp.substr(-4)}-${random}`;
}

// 批量生成兑换码（如游戏关卡奖励）
async function generateCodes(source: string, type: string, value: number, count: number, expireDays: number) {
  const codes = [];
  const expireAt = Date.now() + expireDays * 24 * 3600 * 1000;
  
  for (let i = 0; i < count; i++) {
    const code = generateRedemptionCode();
    codes.push({
      code,
      source,
      type,
      value,
      status: 'active',
      generated_at: Date.now(),
      expire_at: expireAt
    });
  }
  
  await db.redemption_codes.insertMany(codes);
  return codes;
}

// 示例：为游戏第10关生成100个兑换码
await generateCodes('game_level_10', 'quota', 20, 100, 30); // 20次额度，30天有效
```

#### 兑换码API

```typescript
// 兑换
app.post('/api/redemption/redeem', async (req, res) => {
  const { code, userId } = req.body;
  
  // 1. 查询兑换码
  const record = await db.redemption_codes.findOne({ code });
  
  if (!record) {
    return res.json({ success: false, message: '兑换码不存在' });
  }
  
  if (record.status !== 'active') {
    return res.json({ success: false, message: '兑换码已使用或已失效' });
  }
  
  if (record.expire_at < Date.now()) {
    return res.json({ success: false, message: '兑换码已过期' });
  }
  
  // 2. 检查用户是否已兑换过同源兑换码（防止刷）
  const alreadyRedeemed = await db.redemption_codes.findOne({
    source: record.source,
    used_by: userId
  });
  
  if (alreadyRedeemed) {
    return res.json({ success: false, message: '您已兑换过该活动的奖励' });
  }
  
  // 3. 发放奖励
  try {
    if (record.type === 'quota') {
      await grantQuota(userId, record.value);
    } else if (record.type === 'membership') {
      await grantMembership(userId, 'gift', record.value);
    }
    
    // 4. 标记兑换码已使用
    await db.redemption_codes.update(
      { id: record.id },
      { 
        status: 'used', 
        used_by: userId, 
        used_at: Date.now() 
      }
    );
    
    res.json({ 
      success: true, 
      message: `兑换成功！已获得 ${record.value} ${record.type === 'quota' ? '次额度' : '天会员'}`,
      type: record.type,
      value: record.value
    });
  } catch (error) {
    res.json({ success: false, message: '兑换失败，请重试' });
  }
});

// 验证兑换码（不实际兑换，仅查询）
app.get('/api/redemption/validate', async (req, res) => {
  const { code } = req.query;
  
  const record = await db.redemption_codes.findOne({ code });
  
  if (!record) {
    return res.json({ valid: false, message: '兑换码不存在' });
  }
  
  if (record.status !== 'active') {
    return res.json({ valid: false, message: '兑换码已使用或已失效' });
  }
  
  if (record.expire_at < Date.now()) {
    return res.json({ valid: false, message: '兑换码已过期' });
  }
  
  res.json({
    valid: true,
    type: record.type,
    value: record.value,
    expireAt: record.expire_at
  });
});
```

#### 游戏集成示例

```typescript
// 小游戏：通关第10关时弹出兑换码
// game.ts

function onLevelComplete(level: number) {
  if (level === 10) {
    // 请求服务端获取兑换码
    wx.request({
      url: 'https://your-api.com/api/game/get-reward-code',
      method: 'POST',
      data: {
        userId: this.getUserId(),
        level: level
      },
      success: (res) => {
        if (res.data.success) {
          // 显示兑换码弹窗
          wx.showModal({
            title: '🎉 恭喜通关！',
            content: `您的奖励兑换码：\n${res.data.code}\n\n可在"喵喵美颜"小程序兑换 ${res.data.value} 次额度`,
            showCancel: false,
            confirmText: '复制兑换码',
            success: (modalRes) => {
              if (modalRes.confirm) {
                wx.setClipboardData({
                  data: res.data.code,
                  success: () => {
                    wx.showToast({
                      title: '已复制，快去兑换吧！',
                      icon: 'success'
                    });
                  }
                });
              }
            }
          });
        }
      }
    });
  }
}

// 服务端：为通关玩家分配兑换码
app.post('/api/game/get-reward-code', async (req, res) => {
  const { userId, level } = req.body;
  
  // 1. 验证用户确实通关了（防止作弊）
  const userLevel = await db.game_progress.findOne({ user_id: userId });
  if (!userLevel || userLevel.max_level < level) {
    return res.json({ success: false, message: '验证失败' });
  }
  
  // 2. 检查是否已领取过该关卡奖励
  const alreadyRewarded = await db.redemption_codes.findOne({
    source: `game_level_${level}`,
    generated_for: userId
  });
  
  if (alreadyRewarded) {
    return res.json({ 
      success: true, 
      code: alreadyRewarded.code,
      value: alreadyRewarded.value
    });
  }
  
  // 3. 生成专属兑换码
  const code = generateRedemptionCode();
  const value = level === 10 ? 20 : (level === 20 ? 50 : 10);
  
  await db.redemption_codes.insert({
    code,
    source: `game_level_${level}`,
    type: 'quota',
    value,
    status: 'active',
    generated_at: Date.now(),
    expire_at: Date.now() + 30 * 24 * 3600 * 1000, // 30天有效
    generated_for: userId
  });
  
  res.json({ 
    success: true, 
    code,
    value
  });
});
```

---

### 方案4：UnionID 机制（打通多个小程序）

#### 原理

```
同一个微信开放平台账号下的多个小程序：
- 小程序1：openid_1（唯一）
- 小程序2：openid_2（唯一）
- 公众号：openid_3（唯一）

但它们都有同一个 UnionID（跨应用唯一标识）

通过 UnionID 识别同一用户 → 会员体系打通
```

#### 数据库设计

```sql
-- 用户表（跨应用）
CREATE TABLE users (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  unionid VARCHAR(64) NOT NULL UNIQUE, -- 跨应用唯一标识
  nickname VARCHAR(100),
  avatar_url VARCHAR(500),
  created_at BIGINT NOT NULL,
  INDEX idx_unionid (unionid)
);

-- 用户身份表（多个小程序的 openid）
CREATE TABLE user_identities (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  app_id VARCHAR(64) NOT NULL,         -- 小程序/公众号 appid
  openid VARCHAR(64) NOT NULL,         -- 该应用下的 openid
  created_at BIGINT NOT NULL,
  UNIQUE KEY uk_app_openid (app_id, openid),
  INDEX idx_user_id (user_id)
);

-- 会员表（基于 user_id，跨应用通用）
CREATE TABLE memberships (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL UNIQUE,
  type VARCHAR(20) NOT NULL,           -- paid/gift
  expire_at BIGINT NOT NULL,
  created_at BIGINT NOT NULL,
  INDEX idx_user_id (user_id),
  INDEX idx_expire_at (expire_at)
);
```

#### 用户登录流程

```typescript
// 小程序登录
app.post('/api/user/login', async (req, res) => {
  const { code, appId } = req.body; // code 是 wx.login() 获取的
  
  // 1. 向微信服务器换取 openid 和 unionid
  const wxRes = await axios.get('https://api.weixin.qq.com/sns/jscode2session', {
    params: {
      appid: appId,
      secret: 'your-app-secret',
      js_code: code,
      grant_type: 'authorization_code'
    }
  });
  
  const { openid, unionid } = wxRes.data;
  
  if (!unionid) {
    // 如果没有 unionid，说明用户未绑定到开放平台
    // 需要引导用户关注公众号或授权
    return res.json({ success: false, message: '请先授权获取完整信息' });
  }
  
  // 2. 查询或创建用户
  let user = await db.users.findOne({ unionid });
  
  if (!user) {
    // 新用户
    user = await db.users.insert({
      unionid,
      created_at: Date.now()
    });
  }
  
  // 3. 绑定该应用的 openid
  const identity = await db.user_identities.findOne({
    user_id: user.id,
    app_id: appId
  });
  
  if (!identity) {
    await db.user_identities.insert({
      user_id: user.id,
      app_id: appId,
      openid,
      created_at: Date.now()
    });
  }
  
  // 4. 查询会员状态
  const membership = await db.memberships.findOne({ user_id: user.id });
  const isMember = membership && membership.expire_at > Date.now();
  
  // 5. 生成 token
  const token = jwt.sign({ userId: user.id, unionid }, 'your-secret', { expiresIn: '7d' });
  
  res.json({
    success: true,
    token,
    user: {
      id: user.id,
      unionid: user.unionid,
      isMember,
      memberExpireAt: membership?.expire_at
    }
  });
});

// 使用示例：
// 用户在"喵喵美颜"购买会员 → user_id: 123
// 用户打开"PDF转JPG"小程序 → 登录后识别为同一个 user_id: 123 → 自动享有会员权益
```

---

## 📅 分阶段实施计划

### 🎯 阶段0：当前（2025-10-31）

**目标：** 验证产品价值

**任务：**
- ✅ 喵喵美颜已上线
- ✅ 基础分享机制已实现（分享 +10 次）
- ⏳ 收集用户反馈
- ⏳ 优化产品体验

**里程碑：** 获得 100 个真实用户

---

### 🎯 阶段1：公众号基础建设（预计1-2周）

**目标：** 搭建流量中心

#### Week 1：公众号注册与配置

**任务：**
1. 注册微信公众号（服务号，支持自定义菜单和模板消息）
2. 配置服务器（接收微信事件推送）
3. 申请"生成带参数二维码"权限
4. 设计公众号菜单结构：
   ```
   【我的工具】
   ├─ 喵喵美颜
   ├─ PDF转JPG（即将上线）
   └─ 更多工具...
   
   【领取额度】
   ├─ 关注奖励（50次）
   ├─ 整点抢券
   └─ 兑换码
   
   【我的账户】
   ├─ 会员中心
   └─ 联系客服
   ```

**技术要点：**
- 服务端需要处理微信事件（subscribe/unsubscribe/CLICK/message）
- 验证微信服务器签名（signature验证）
- 配置"业务域名"和"JS接口安全域名"

**完成标准：**
- 公众号可以接收用户关注/取关事件
- 自定义菜单可以跳转小程序
- 可以向用户发送文本/图文消息

---

#### Week 2：关注奖励功能

**任务：**
1. 实现"验证码机制"方案
2. 创建数据库表（verification_codes, follow_history）
3. 开发服务端API（生成验证码、验证验证码、处理关注事件）
4. 在小程序内添加"关注领50次"入口
5. 测试完整流程

**技术要点：**
- 验证码5分钟有效期
- 反作弊机制（7天内关注-取关超过3次不发放奖励）
- 每个用户只能领取1次关注奖励

**完成标准：**
- 用户可以通过验证码机制领取50次额度
- 取关后标记记录，再次关注不重复发放
- 异常行为检测正常工作

---

### 🎯 阶段2：整点抢券系统（预计1周）

**目标：** 增加用户活跃度和粘性

**任务：**
1. 创建数据库表（coupon_events, coupon_claims）
2. 开发定时任务（每天创建活动、活动状态管理）
3. 开发服务端API（获取活动信息、抢券、最近领取动态）
4. 使用Redis实现原子操作（防止超发）
5. 在小程序内创建"整点抢券"页面
6. 实现订阅消息提醒（提前10分钟）

**技术要点：**
- Redis INCR 原子操作保证不超发
- 定时任务准时激活活动
- 前端实时更新剩余名额
- 社交证明（"已有23人领取"）

**完成标准：**
- 每天12:00和18:00自动开始抢券
- 100个名额不会超发
- 用户可以看到实时进度和动态
- 订阅提醒可以正常推送

---

### 🎯 阶段3：兑换码系统（预计1周）

**目标：** 为后续游戏/答题小程序做准备

**任务：**
1. 创建数据库表（redemption_codes）
2. 开发兑换码生成逻辑
3. 开发服务端API（兑换、验证）
4. 在小程序内添加"兑换码"入口
5. 在公众号内添加"兑换码"菜单（跳转小程序）

**技术要点：**
- 兑换码格式：MM-3K5J-2A9X（易识别、不易输错）
- 防刷机制（同源兑换码每人只能兑换1次）
- 兑换码有效期管理

**完成标准：**
- 可以批量生成兑换码
- 用户可以在小程序内输入兑换码领取奖励
- 同一个兑换码只能使用1次
- 同一来源的奖励每人只能领取1次

---

### 🎯 阶段4：第二个小程序（预计2-3周）

**目标：** 验证矩阵模式

**任务：**
1. 选择开发"PDF转JPG"或其他高频工具
2. 开发小程序（复用喵喵美颜的框架）
3. 接入UnionID机制
4. 打通会员体系
5. 在公众号添加入口

**技术要点：**
- 统一用户登录逻辑（基于UnionID）
- 会员权益跨应用生效
- 额度系统跨应用共享（可选）

**完成标准：**
- 新小程序可以独立运行
- 用户在任一小程序购买会员，在另一个小程序也生效
- 公众号菜单可以跳转到两个小程序

---

### 🎯 阶段5：小游戏开发（预计1-2个月）

**目标：** 增加趣味性和广告变现

**任务：**
1. 设计小游戏玩法（如消除类、跑酷类）
2. 集成微信小游戏广告（激励视频广告）
3. 通关奖励兑换码
4. 在公众号添加入口

**技术要点：**
- 小游戏框架（Cocos Creator / LayaAir / 原生Canvas）
- 激励视频广告集成
- 防作弊机制（服务端验证通关）

**完成标准：**
- 小游戏可以正常运行
- 通关后弹出兑换码
- 广告播放正常，有收益
- 兑换码可以在喵喵美颜小程序兑换

---

### 🎯 阶段6：答题小程序（预计2-3周）

**目标：** 知识类内容，增加用户停留时间

**任务：**
1. 设计题库（知识问答、趣味测试）
2. 开发答题小程序
3. 集成广告（插屏广告、激励视频广告）
4. 答题任务奖励兑换码
5. 在公众号添加入口

**完成标准：**
- 答题小程序可以正常运行
- 完成任务后获得兑换码
- 广告播放正常

---

## ⚠️ 风险与注意事项

### 1. 合规风险

**微信平台规则：**
- ❌ **诱导分享**：严格禁止
  - "分享到朋友圈才能继续使用"
  - "分享给5个好友才能解锁"
  - "分享后显示答案"
  
- ❌ **虚假宣传**：可能被投诉
  - "已有1000人领取"（实际只有10人）
  - "限时免费"（实际一直免费）
  
- ❌ **过度营销**：可能被限流
  - 频繁推送消息
  - 强制关注公众号
  
**解决方案：**
- ✅ 提供多种获取额度方式（分享/广告/任务）
- ✅ 使用真实数据或合理估算
- ✅ 订阅消息由用户主动授权
- ✅ 关注公众号是奖励而不是强制

---

### 2. 技术风险

**高并发问题：**
- **整点抢券**可能瞬间涌入大量请求
- **解决方案**：
  - 使用Redis原子操作（INCR/DECR）
  - 接口限流（每个用户5秒内只能请求1次）
  - CDN加速静态资源

**数据一致性：**
- UnionID绑定可能失败
- **解决方案**：
  - 使用事务保证数据一致性
  - 定期校验数据
  - 日志记录所有关键操作

**用户体验：**
- 跨应用跳转可能中断流程
- **解决方案**：
  - 优化跳转路径（公众号菜单直接跳转）
  - 小程序内嵌H5页面（如兑换码页面）
  - 提供清晰的引导文案

---

### 3. 运营风险

**用户留存：**
- 如果产品不够刚需，用户可能领完额度就走
- **解决方案**：
  - 做好核心产品（如喵喵美颜）
  - 定期推出新功能
  - 公众号推送有价值的内容（不只是营销）

**羊毛党：**
- 可能有人批量注册账号刷奖励
- **解决方案**：
  - 设备指纹识别
  - 行为分析（短时间大量操作 = 异常）
  - 同IP限制
  - 手机号验证（高价值奖励）

**成本控制：**
- 广告收益可能不足以覆盖服务器成本
- **解决方案**：
  - 初期控制规模（如整点抢券每天只放200个名额）
  - 监控成本和收益
  - 必要时引入付费会员

---

### 4. 开发成本

**预估工作量：**
- 阶段1-3（公众号+抢券+兑换码）：**3-4周**
- 阶段4（第二个小程序）：**2-3周**
- 阶段5（小游戏）：**1-2个月**（取决于复杂度）
- 阶段6（答题小程序）：**2-3周**

**总计：** 约 **3-4个月** 可以搭建起完整矩阵

**降低成本的方法：**
- 复用代码（小程序框架、登录逻辑、会员系统）
- 使用开源组件（如答题小程序可以找开源模板）
- 优先开发MVP，逐步迭代

---

## 🚀 立即可以开始的工作

### 1. 注册公众号
- 前往 [微信公众平台](https://mp.weixin.qq.com/)
- 选择"服务号"（支持更多功能）
- 准备资料：营业执照、身份证、对公账户（如果是企业）

### 2. 申请微信开放平台账号
- 前往 [微信开放平台](https://open.weixin.qq.com/)
- 绑定公众号和小程序
- 获取UnionID能力

### 3. 设计数据库表结构
- 按照上面的方案创建表
- 可以先在本地MySQL测试

### 4. 开发公众号后台
- 搭建Node.js服务器（或其他后端）
- 接收微信事件推送
- 处理用户关注/取关/消息

### 5. 在喵喵美颜添加"关注领50次"入口
- 创建新页面 `pages/follow-reward/follow-reward`
- 实现验证码机制

---

## 📝 快速参考

### 关键API文档

- [微信公众平台开发文档](https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html)
- [微信小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)
- [UnionID机制说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html)
- [订阅消息](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html)

### 技术栈建议

**后端：**
- Node.js + Express（轻量级，适合快速开发）
- MySQL（关系型数据库，结构化数据）
- Redis（缓存、原子操作、会话管理）

**前端：**
- 小程序原生框架（官方支持好，性能优）
- 或 Taro / uni-app（跨端开发，一套代码多端运行）

**部署：**
- 腾讯云 / 阿里云（小程序和公众号在国内，选国内服务器）
- Docker + PM2（容器化部署，自动重启）
- Nginx（反向代理，HTTPS证书）

---

## 💬 最后建议

1. **先做好一个产品**
   - 喵喵美颜先积累1000个活跃用户
   - 验证"分享机制"是否有效
   - 收集用户画像和需求

2. **再扩展矩阵**
   - 基于用户反馈，决定下一个产品方向
   - 优先做"高频刚需"（如PDF转JPG）

3. **公众号是关键**
   - 作为流量中心和用户触达渠道
   - 定期推送价值内容（不只是广告）
   - 建立用户信任

4. **合规第一**
   - 微信的规则很严格
   - 诱导分享、虚假宣传都可能导致封号
   - 建议先小规模测试，观察平台反馈

5. **数据驱动**
   - 记录所有关键指标（DAU、留存率、转化率）
   - 定期分析数据，优化策略
   - A/B测试不同方案

---

**祝你睡个好觉！醒来后就可以根据这份文档开始开发了！💪✨**

如果有任何疑问，可以随时问我！

